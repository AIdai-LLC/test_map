'use strict';var vuePropertyDecorator=require('vue-property-decorator');// Google Maps base URL
const baseURL = 'https://maps.googleapis.com/maps/api/js';
// Google Maps full URL with query parameters
const genURL = options => `${baseURL}?${options}`;
// All promises that need to be resolved once map is loaded
const promises = [];
// onError callback for Google Maps fail
const onError = e => promises.forEach(p => p.reject(e));
// onLoad callback for Google Maps load
const onLoad = () => promises.forEach(p => p.resolve(globalThis.google.maps));
// Insert the Google Maps script into the DOM
const loadAPI = options => {
  const script = document.createElement('script');
  script.type = 'text/javascript';
  script.src = genURL(options);
  script.onerror = () => onError(new Error('Error loading script'));
  script.onload = () => onLoad();
  const head = document.querySelector('head');
  if (head) head.appendChild(script);
};
// Convert options object into URI parameters
const uriX5OptionsInterface = options => `key=${options.key}&libraries=${options.libraries.join(',')}`;
// Check if loaded
const loaded = () => !!globalThis.google && !!globalThis.google.maps;
// Loading flag to allow for multiple inits
let loading = false;
// Exported promise to get map
const gmaps = () => {
  // Early return if map already loaded
  if (loaded()) return Promise.resolve(globalThis.google.maps);
  // If not loading, it was not initialised
  if (!loading) throw new Error('x5GMaps :: Plugin not initialised');
  // Return promise and save for resolution when map load completes
  return new Promise((resolve, reject) => promises.push({
    resolve,
    reject
  }));
};
// Exported initialisation
const init = options => {
  // Early return if map already loaded
  if (loaded()) throw new Error('x5GMaps :: Plugin already initialised');
  // Initiate map loading with given key, any options, and a promise resolve callback
  loadAPI(uriX5OptionsInterface(options));
  // Map is still loading
  loading = true;
  // Give up if map takes too long
  setTimeout(() => {
    if (!loaded()) onError(new Error('Loading timed out'));
  }, 5000);
};function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _initializerDefineProperty(target, property, descriptor, context) {
  if (!descriptor) return;
  Object.defineProperty(target, property, {
    enumerable: descriptor.enumerable,
    configurable: descriptor.configurable,
    writable: descriptor.writable,
    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
  });
}
function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object.keys(descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;
  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }
  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);
  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }
  if (desc.initializer === void 0) {
    Object.defineProperty(target, property, desc);
    desc = null;
  }
  return desc;
}var _dec$c, _dec2$c, _dec3$c, _dec4$c, _class$c, _class2$c, _descriptor$c, _descriptor2$c, _descriptor3$c;
const defaultOptions$1 = {
  center: {
    lat: -27.5,
    lng: 153
  },
  zoom: 12
};
let GmapsMap = (_dec$c = vuePropertyDecorator.Prop({
  default: () => ({})
}), _dec2$c = vuePropertyDecorator.Provide('getMap'), _dec3$c = vuePropertyDecorator.Provide('handleError'), _dec4$c = vuePropertyDecorator.Watch('options', {
  immediate: true,
  deep: true
}), vuePropertyDecorator.Component(_class$c = (_class2$c = class GmapsMap extends vuePropertyDecorator.Vue {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", 'gmapsMap');
    _initializerDefineProperty(this, "options", _descriptor$c, this);
    _defineProperty(this, "error", null);
    _defineProperty(this, "loading", true);
    _defineProperty(this, "map", void 0);
    _initializerDefineProperty(this, "provideMap", _descriptor2$c, this);
    _initializerDefineProperty(this, "handleError", _descriptor3$c, this);
  }
  getMap() {
    if (this.map) return this.map;
    throw new Error('Map not found.');
  }
  _handleError(e) {
    this.error = e.message;
  }
  optionsChanged(newVal) {
    if (this.map) this.map.setOptions(newVal);
  }
  mounted() {
    gmaps().then(maps => {
      this.map = new maps.Map(this.$refs.gmap, {
        ...defaultOptions$1,
        ...this.options
      });
      this.$emit('mounted', this.map);
      this.map.addListener('idle', () => this.$emit('idle', true));
      this.map.addListener('bounds_changed', () => this.$emit('bounds-changed', this.map.getBounds()));
      this.map.addListener('center_changed', () => this.$emit('center-changed', this.map.getCenter()));
      this.map.addListener('click', e => this.$emit('click', e));
      this.map.addListener('dblclick', e => this.$emit('double-click', e));
      this.map.addListener('rightclick', e => this.$emit('right-click', e));
      this.map.addListener('zoom_changed', () => this.$emit('zoom-changed', this.map.getZoom()));
      // TODO: Remove in major release
      this.map.addListener('bounds_changed', () => this.$emit('boundsChanged', this.map.getBounds())); // eslint-disable-line
      this.map.addListener('center_changed', () => this.$emit('centerChanged', this.map.getCenter())); // eslint-disable-line
      this.map.addListener('dblclick', e => this.$emit('doubleClick', e)); // eslint-disable-line
      this.map.addListener('rightclick', e => this.$emit('rightClick', e)); // eslint-disable-line
      this.map.addListener('zoom_changed', () => this.$emit('zoomChanged', this.map.getZoom())); // eslint-disable-line
      setTimeout(() => this.loading = false, 100);
    }).catch(e => this._handleError(e));
  }
  beforeDestroy() {
    if (this.map) globalThis.google.maps.event.clearInstanceListeners(this.map);
  }
}, (_descriptor$c = _applyDecoratedDescriptor(_class2$c.prototype, "options", [_dec$c], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2$c = _applyDecoratedDescriptor(_class2$c.prototype, "provideMap", [_dec2$c], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return () => this.getMap();
  }
}), _descriptor3$c = _applyDecoratedDescriptor(_class2$c.prototype, "handleError", [_dec3$c], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return e => this._handleError(e);
  }
}), _applyDecoratedDescriptor(_class2$c.prototype, "optionsChanged", [_dec4$c], Object.getOwnPropertyDescriptor(_class2$c.prototype, "optionsChanged"), _class2$c.prototype)), _class2$c)) || _class$c);function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    if (typeof shadowMode !== 'boolean') {
        createInjectorSSR = createInjector;
        createInjector = shadowMode;
        shadowMode = false;
    }
    // Vue.extend constructor export interop.
    const options = typeof script === 'function' ? script.options : script;
    // render functions
    if (template && template.render) {
        options.render = template.render;
        options.staticRenderFns = template.staticRenderFns;
        options._compiled = true;
        // functional template
        if (isFunctionalTemplate) {
            options.functional = true;
        }
    }
    // scopedId
    if (scopeId) {
        options._scopeId = scopeId;
    }
    let hook;
    if (moduleIdentifier) {
        // server build
        hook = function (context) {
            // 2.3 injection
            context =
                context || // cached call
                    (this.$vnode && this.$vnode.ssrContext) || // stateful
                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
            // 2.2 with runInNewContext: true
            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
                context = __VUE_SSR_CONTEXT__;
            }
            // inject component styles
            if (style) {
                style.call(this, createInjectorSSR(context));
            }
            // register component module identifier for async chunk inference
            if (context && context._registeredComponents) {
                context._registeredComponents.add(moduleIdentifier);
            }
        };
        // used by ssr in case component is cached and beforeCreate
        // never gets called
        options._ssrRegister = hook;
    }
    else if (style) {
        hook = shadowMode
            ? function (context) {
                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
            }
            : function (context) {
                style.call(this, createInjector(context));
            };
    }
    if (hook) {
        if (options.functional) {
            // register for functional component in vue file
            const originalRender = options.render;
            options.render = function renderWithStyleInjection(h, context) {
                hook.call(context);
                return originalRender(h, context);
            };
        }
        else {
            // inject component registration as beforeCreate hook
            const existing = options.beforeCreate;
            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
    }
    return script;
}function createInjectorSSR(context) {
    if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__;
    }
    if (!context)
        return () => { };
    if (!('styles' in context)) {
        context._styles = context._styles || {};
        Object.defineProperty(context, 'styles', {
            enumerable: true,
            get: () => context._renderStyles(context._styles)
        });
        context._renderStyles = context._renderStyles || renderStyles;
    }
    return (id, style) => addStyle(id, style, context);
}
function addStyle(id, css, context) {
    const group = css.media || 'default' ;
    const style = context._styles[group] || (context._styles[group] = { ids: [], css: '' });
    if (!style.ids.includes(id)) {
        style.media = css.media;
        style.ids.push(id);
        let code = css.source;
        style.css += code + '\n';
    }
}
function renderStyles(styles) {
    let css = '';
    for (const key in styles) {
        const style = styles[key];
        css +=
            '<style data-vue-ssr-id="' +
                Array.from(style.ids).join(' ') +
                '"' +
                (style.media ? ' media="' + style.media + '"' : '') +
                '>' +
                style.css +
                '</style>';
    }
    return css;
}/* script */
const __vue_script__$3 = GmapsMap;

/* template */
var __vue_render__$3 = function () {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c('div', {
    staticClass: "gmaps-map"
  }, [_vm.error ? [_vm._t("error", function () {
    return [_c('span', {
      staticClass: "gmaps-error"
    }, [_vm._v("Error: " + _vm._s(_vm.error))])];
  }, {
    "error": _vm.error
  })] : _vm.loading ? [_vm._t("loading", function () {
    return [_c('span', {
      staticClass: "gmaps-spinner"
    })];
  })] : _vm._e(), _vm._ssrNode(" "), _vm._ssrNode("<div class=\"gmaps-map\"" + _vm._ssrStyle(null, null, {
    display: !_vm.error ? '' : 'none'
  }) + ">", "</div>", [!_vm.error && !_vm.loading && !!_vm.map ? _vm._t("default", null, {
    "map": _vm.map
  }) : _vm._e()], 2)], 2);
};
var __vue_staticRenderFns__$3 = [];

/* style */
const __vue_inject_styles__$3 = function (inject) {
  if (!inject) return;
  inject("data-v-cea96fac_0", {
    source: ".gmaps-map{position:relative;width:100%;height:100%}.gmaps-spinner{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%)}.gmaps-spinner::after{content:\"\";display:inline-block;width:200px;height:200px;border:20px solid #ccc;border-radius:50%;border-top-color:#aaa;animation:gmaps-spin 1s ease-in-out infinite}.gmaps-error{position:absolute;top:50%;left:5%;width:90%;transform:translateY(-50%);color:#af0000;font-size:24px}@keyframes gmaps-spin{to{transform:rotate(360deg)}}",
    map: undefined,
    media: undefined
  });
};
/* scoped */
const __vue_scope_id__$3 = undefined;
/* module identifier */
const __vue_module_identifier__$3 = "data-v-cea96fac";
/* functional template */
const __vue_is_functional_template__$3 = false;
/* style inject shadow dom */

const __vue_component__$3 = /*#__PURE__*/normalizeComponent({
  render: __vue_render__$3,
  staticRenderFns: __vue_staticRenderFns__$3
}, __vue_inject_styles__$3, __vue_script__$3, __vue_scope_id__$3, __vue_is_functional_template__$3, __vue_module_identifier__$3, false, undefined, createInjectorSSR, undefined);var _dec$b, _dec2$b, _dec3$b, _dec4$b, _dec5$9, _dec6$7, _dec7$6, _dec8$5, _dec9$5, _dec10$4, _dec11$4, _dec12$4, _dec13$3, _dec14$3, _dec15$2, _dec16$1, _class$b, _class2$b, _descriptor$b, _descriptor2$b, _descriptor3$b, _descriptor4$8, _descriptor5$6, _descriptor6$5, _descriptor7$5, _descriptor8$5, _descriptor9$4, _descriptor10$4, _descriptor11$4, _descriptor12$3, _descriptor13$3, _descriptor14$2, _descriptor15$1;
let GmapsCircle = (_dec$b = vuePropertyDecorator.Inject('getMap'), _dec2$b = vuePropertyDecorator.Prop({
  default: 0.001
}), _dec3$b = vuePropertyDecorator.Prop({
  required: true
}), _dec4$b = vuePropertyDecorator.Prop({
  required: true
}), _dec5$9 = vuePropertyDecorator.Prop({
  default: true
}), _dec6$7 = vuePropertyDecorator.Prop({
  default: false
}), _dec7$6 = vuePropertyDecorator.Prop({
  default: false
}), _dec8$5 = vuePropertyDecorator.Prop({
  default: 'black'
}), _dec9$5 = vuePropertyDecorator.Prop({
  default: 0.3
}), _dec10$4 = vuePropertyDecorator.Prop({
  default: 'black'
}), _dec11$4 = vuePropertyDecorator.Prop({
  default: 1.0
}), _dec12$4 = vuePropertyDecorator.Prop({
  default: 0
}), _dec13$3 = vuePropertyDecorator.Prop({
  default: 3
}), _dec14$3 = vuePropertyDecorator.Prop({
  default: true
}), _dec15$2 = vuePropertyDecorator.Prop({
  default: 0
}), _dec16$1 = vuePropertyDecorator.Watch('_options', {
  immediate: true,
  deep: true
}), vuePropertyDecorator.Component(_class$b = (_class2$b = class GmapsCircle extends vuePropertyDecorator.Vue {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", 'gmapsCircle');
    _initializerDefineProperty(this, "getMap", _descriptor$b, this);
    _initializerDefineProperty(this, "sensitivity", _descriptor2$b, this);
    _initializerDefineProperty(this, "center", _descriptor3$b, this);
    _initializerDefineProperty(this, "radius", _descriptor4$8, this);
    _initializerDefineProperty(this, "clickable", _descriptor5$6, this);
    _initializerDefineProperty(this, "draggable", _descriptor6$5, this);
    _initializerDefineProperty(this, "editable", _descriptor7$5, this);
    _initializerDefineProperty(this, "fillColor", _descriptor8$5, this);
    _initializerDefineProperty(this, "fillOpacity", _descriptor9$4, this);
    _initializerDefineProperty(this, "strokeColor", _descriptor10$4, this);
    _initializerDefineProperty(this, "strokeOpacity", _descriptor11$4, this);
    _initializerDefineProperty(this, "strokePosition", _descriptor12$3, this);
    _initializerDefineProperty(this, "strokeWeight", _descriptor13$3, this);
    _initializerDefineProperty(this, "visible", _descriptor14$2, this);
    _initializerDefineProperty(this, "zIndex", _descriptor15$1, this);
    _defineProperty(this, "circle", void 0);
    _defineProperty(this, "tempCenter", this.center);
    _defineProperty(this, "tempRadius", +this.radius);
  }
  get _options() {
    return {
      center: this.center,
      clickable: this.clickable,
      draggable: this.draggable,
      editable: this.editable,
      fillColor: this.fillColor,
      fillOpacity: +this.fillOpacity,
      radius: +this.radius,
      strokeColor: this.strokeColor,
      strokeOpacity: +this.strokeOpacity,
      strokePosition: +this.strokePosition,
      strokeWeight: +this.strokeWeight,
      visible: this.visible,
      zIndex: +this.zIndex
    };
  }
  _optionsChanged(newVal) {
    if (this.circle) this.circle.setOptions(newVal);
  }
  changedCenter() {
    if (!this.circle) return;
    // This is fired when the component is replaced and may not have a tempCenter
    const newCenter = this.circle.getCenter().toJSON();
    if (!this.tempCenter || Math.abs(newCenter.lat - this.tempCenter.lat) > this.sensitivity || Math.abs(newCenter.lng - this.tempCenter.lng) > this.sensitivity) {
      this.tempCenter = newCenter;
      this.$emit('center-changed', newCenter);
      // TODO: Remove in major release
      this.$emit('centerChanged', newCenter); // eslint-disable-line
    }
  }

  changedRadius() {
    if (!this.circle) return;
    // This is fired when the component is replaced and may not have a tempCenter
    const newRadius = this.circle.getRadius();
    if (!this.tempRadius || Math.abs(newRadius - this.tempRadius) > 1) {
      this.tempRadius = newRadius;
      this.$emit('radius-changed', newRadius);
      // TODO: Remove in major release
      this.$emit('radiusChanged', newRadius); // eslint-disable-line
    }
  }

  mounted() {
    this.circle = new globalThis.google.maps.Circle({
      map: this.getMap(),
      ...this._options
    });
    this.circle.addListener('center_changed', () => this.changedCenter());
    this.circle.addListener('radius_changed', () => this.changedRadius());
    this.circle.addListener('click', e => this.$emit('click', e));
    this.circle.addListener('dblclick', e => this.$emit('double-click', e));
    this.circle.addListener('drag', e => this.$emit('drag', e.latLng ? e.latLng.toJSON() : null));
    this.circle.addListener('dragend', e => this.$emit('drag-end', e.latLng ? e.latLng.toJSON() : null));
    this.circle.addListener('dragstart', e => this.$emit('drag-start', e.latLng ? e.latLng.toJSON() : null));
    this.circle.addListener('mouseover', e => this.$emit('mouseover', e));
    this.circle.addListener('rightclick', e => this.$emit('right-click', e));
    // TODO: Remove in major release
    this.circle.addListener('dblclick', e => this.$emit('doubleClick', e)); // eslint-disable-line
    this.circle.addListener('dragend', e => this.$emit('dragEnd', e.latLng ? e.latLng.toJSON() : null)); // eslint-disable-line
    this.circle.addListener('dragstart', e => this.$emit('dragStart', e.latLng ? e.latLng.toJSON() : null)); // eslint-disable-line
    this.circle.addListener('rightclick', e => this.$emit('rightClick', e)); // eslint-disable-line
  }

  beforeDestroy() {
    if (this.circle) this.circle.setMap(null);
  }
  render() {
    return null;
  }
}, (_descriptor$b = _applyDecoratedDescriptor(_class2$b.prototype, "getMap", [_dec$b], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2$b = _applyDecoratedDescriptor(_class2$b.prototype, "sensitivity", [_dec2$b], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3$b = _applyDecoratedDescriptor(_class2$b.prototype, "center", [_dec3$b], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4$8 = _applyDecoratedDescriptor(_class2$b.prototype, "radius", [_dec4$b], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor5$6 = _applyDecoratedDescriptor(_class2$b.prototype, "clickable", [_dec5$9], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor6$5 = _applyDecoratedDescriptor(_class2$b.prototype, "draggable", [_dec6$7], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor7$5 = _applyDecoratedDescriptor(_class2$b.prototype, "editable", [_dec7$6], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor8$5 = _applyDecoratedDescriptor(_class2$b.prototype, "fillColor", [_dec8$5], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor9$4 = _applyDecoratedDescriptor(_class2$b.prototype, "fillOpacity", [_dec9$5], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor10$4 = _applyDecoratedDescriptor(_class2$b.prototype, "strokeColor", [_dec10$4], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor11$4 = _applyDecoratedDescriptor(_class2$b.prototype, "strokeOpacity", [_dec11$4], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor12$3 = _applyDecoratedDescriptor(_class2$b.prototype, "strokePosition", [_dec12$4], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor13$3 = _applyDecoratedDescriptor(_class2$b.prototype, "strokeWeight", [_dec13$3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor14$2 = _applyDecoratedDescriptor(_class2$b.prototype, "visible", [_dec14$3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor15$1 = _applyDecoratedDescriptor(_class2$b.prototype, "zIndex", [_dec15$2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _applyDecoratedDescriptor(_class2$b.prototype, "_optionsChanged", [_dec16$1], Object.getOwnPropertyDescriptor(_class2$b.prototype, "_optionsChanged"), _class2$b.prototype)), _class2$b)) || _class$b);const EXTEND = 0.1;

// Get bounds
const getBounds = items => {
  const _bounds = new globalThis.google.maps.LatLngBounds(items[0], items[0]);
  items.forEach(e => _bounds.extend(e));
  return _bounds;
};

// Get bounds
const extendBounds = bounds => {
  const span = bounds.toSpan().toJSON();
  const north = Math.min(bounds.toJSON().north + EXTEND * span.lat, +89);
  const south = Math.max(bounds.toJSON().south - EXTEND * span.lat, -89);
  const west = Math.max(bounds.toJSON().west - EXTEND * span.lng, -180);
  const east = Math.min(bounds.toJSON().east + EXTEND * span.lng, +180);
  return new globalThis.google.maps.LatLngBounds(new globalThis.google.maps.LatLng({
    lat: south,
    lng: west
  }), new globalThis.google.maps.LatLng({
    lat: north,
    lng: east
  }));
};// https://developers.google.com/maps/documentation/javascript/examples/map-coordinates
const getMapTile = (pos, zoom, size) => {
  const scale = 1 << zoom;
  let siny = Math.sin(pos.lat * Math.PI / 180);
  siny = Math.min(Math.max(siny, -0.9999), 0.9999);
  const x0 = 0.5 + pos.lng / 360;
  const y0 = 0.5 - Math.log((1 + siny) / (1 - siny)) / (4 * Math.PI);
  const x = Math.floor(x0 * scale / size);
  const y = Math.floor(y0 * scale / size);
  return {
    x,
    y
  };
};

// Get average position
const getAveragePosition = items => {
  const _count = items.length;
  const _init = {
    lat: 0,
    lng: 0
  };
  const _posTot = items.reduce((acc, cur) => ({
    lat: acc.lat + cur.lat,
    lng: acc.lng + cur.lng
  }), _init);
  const pos = {
    lat: _posTot.lat / _count,
    lng: _posTot.lng / _count
  };
  return pos;
};

// Get weight
const getWeight = (cluster, total) => {
  return Math.round(cluster / total * 100);
};

// Organise a given set of items into tiles of given size and appropriate for a given zoom
const organiseClusters = (items, zoom, maxZoom, tileSize) => {
  const result = {};
  // If zoom exceeds maxZoom, do not cluster
  if (zoom >= maxZoom) {
    items.forEach((item, index) => {
      result[index] = {
        pos: item,
        items: [item]
      };
    });
    // Otherwise, cluster
  } else {
    // Cluster by tile
    items.forEach(item => {
      const tile = getMapTile(item, zoom, tileSize);
      const index = `${zoom}-${tile.x}-${tile.y}`;
      if (!result[index]) result[index] = {
        pos: {
          lat: 0,
          lng: 0
        },
        items: []
      };
      result[index].items.push(item);
    });
    // Set average positions and weights
    for (const [key, value] of Object.entries(result)) {
      result[key].pos = getAveragePosition(value.items);
      result[key].weight = getWeight(value.items.length, items.length);
    }
  }
  return result;
};var _dec$a, _dec2$a, _dec3$a, _dec4$a, _dec5$8, _dec6$6, _dec7$5, _dec8$4, _dec9$4, _dec10$3, _dec11$3, _dec12$3, _class$a, _class2$a, _descriptor$a, _descriptor2$a, _descriptor3$a, _descriptor4$7, _descriptor5$5, _descriptor6$4, _descriptor7$4, _descriptor8$4, _descriptor9$3, _descriptor10$3, _descriptor11$3;
let GmapsMarker = (_dec$a = vuePropertyDecorator.Inject('getMap'), _dec2$a = vuePropertyDecorator.Inject('handleError'), _dec3$a = vuePropertyDecorator.Prop({
  default: () => ({})
}), _dec4$a = vuePropertyDecorator.Prop({
  default: 0.001
}), _dec5$8 = vuePropertyDecorator.Prop({
  default: true
}), _dec6$6 = vuePropertyDecorator.Prop({
  default: undefined
}), _dec7$5 = vuePropertyDecorator.Prop({
  default: undefined
}), _dec8$4 = vuePropertyDecorator.Prop({
  default: undefined
}), _dec9$4 = vuePropertyDecorator.Prop({
  default: undefined
}), _dec10$3 = vuePropertyDecorator.Prop({
  default: undefined
}), _dec11$3 = vuePropertyDecorator.Prop({
  default: undefined
}), _dec12$3 = vuePropertyDecorator.Watch('_options', {
  immediate: true,
  deep: true
}), vuePropertyDecorator.Component(_class$a = (_class2$a = class GmapsMarker extends vuePropertyDecorator.Vue {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", 'gmapsMarker');
    _initializerDefineProperty(this, "getMap", _descriptor$a, this);
    _initializerDefineProperty(this, "handleError", _descriptor2$a, this);
    _initializerDefineProperty(this, "options", _descriptor3$a, this);
    _initializerDefineProperty(this, "sensitivity", _descriptor4$7, this);
    _initializerDefineProperty(this, "visible", _descriptor5$5, this);
    _initializerDefineProperty(this, "icon", _descriptor6$4, this);
    _initializerDefineProperty(this, "label", _descriptor7$4, this);
    _initializerDefineProperty(this, "opacity", _descriptor8$4, this);
    _initializerDefineProperty(this, "position", _descriptor9$3, this);
    _initializerDefineProperty(this, "title", _descriptor10$3, this);
    _initializerDefineProperty(this, "zIndex", _descriptor11$3, this);
    _defineProperty(this, "marker", void 0);
  }
  get _options() {
    const options = {
      ...this.options
    };
    if (this.visible) options.visible = this.visible;
    if (this.icon) options.icon = this.icon;
    if (this.label) options.label = this.label;
    if (this.opacity) options.opacity = +this.opacity;
    if (this.position) options.position = this.position;
    if (this.title) options.title = this.title;
    if (this.zIndex) options.zIndex = +this.zIndex;
    return options;
  }
  _optionsChanged(newVal) {
    if (this.marker) this.marker.setOptions(newVal);
  }
  changedPosition() {
    const oldPosition = this._options.position;
    // This function is fired when a marker is replaced by Vue (and options is undefined)
    if (!oldPosition) return false;
    const newPosition = this.marker.getPosition().toJSON();
    return Math.abs(newPosition.lat - oldPosition.lat) > this.sensitivity || Math.abs(newPosition.lng - oldPosition.lng) > this.sensitivity ? newPosition : false;
  }
  mounted() {
    // Early return for no position
    if (!this._options.position) return this.handleError(new Error('x5-gmaps: A position is required by every marker. Set this as either a position prop, or a position property of the options prop.'));
    this.marker = new globalThis.google.maps.Marker({
      map: this.getMap(),
      ...this._options
    });
    this.marker.addListener('position_changed', () => {
      const position = this.changedPosition();
      if (position) {
        this.$emit('move', position);
        // Depreciated 19/04
        this.$emit('position-changed', position);
      }
    });
    this.marker.addListener('click', e => this.$emit('click', e));
    this.marker.addListener('dblclick', e => this.$emit('double-click', e));
    this.marker.addListener('rightclick', e => this.$emit('right-click', e));
    this.marker.addListener('mouseover', e => this.$emit('mouseover', e));
    this.marker.addListener('mouseout', e => this.$emit('mouseout', e));
    this.marker.addListener('drag', e => this.$emit('drag', e));
    this.marker.addListener('dragend', e => this.$emit('dragend', e));
    this.marker.addListener('dragstart', e => this.$emit('dragstart', e));
    // TODO: Remove in major release
    this.marker.addListener('dblclick', e => this.$emit('doubleClick', e)); // eslint-disable-line
    this.marker.addListener('rightclick', e => this.$emit('rightClick', e)); // eslint-disable-line
  }

  beforeDestroy() {
    if (this.marker) google.maps.event.clearInstanceListeners(this.marker);
    if (this.marker) this.marker.setMap(null);
  }
  render() {
    return null;
  }
}, (_descriptor$a = _applyDecoratedDescriptor(_class2$a.prototype, "getMap", [_dec$a], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2$a = _applyDecoratedDescriptor(_class2$a.prototype, "handleError", [_dec2$a], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3$a = _applyDecoratedDescriptor(_class2$a.prototype, "options", [_dec3$a], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4$7 = _applyDecoratedDescriptor(_class2$a.prototype, "sensitivity", [_dec4$a], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor5$5 = _applyDecoratedDescriptor(_class2$a.prototype, "visible", [_dec5$8], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor6$4 = _applyDecoratedDescriptor(_class2$a.prototype, "icon", [_dec6$6], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor7$4 = _applyDecoratedDescriptor(_class2$a.prototype, "label", [_dec7$5], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor8$4 = _applyDecoratedDescriptor(_class2$a.prototype, "opacity", [_dec8$4], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor9$3 = _applyDecoratedDescriptor(_class2$a.prototype, "position", [_dec9$4], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor10$3 = _applyDecoratedDescriptor(_class2$a.prototype, "title", [_dec10$3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor11$3 = _applyDecoratedDescriptor(_class2$a.prototype, "zIndex", [_dec11$3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _applyDecoratedDescriptor(_class2$a.prototype, "_optionsChanged", [_dec12$3], Object.getOwnPropertyDescriptor(_class2$a.prototype, "_optionsChanged"), _class2$a.prototype)), _class2$a)) || _class$a);// TODO: Can't figure out the type vs class definition here
const createPopupClass = () => {
  /**
   * A customized popup on the map.
   */
  return class Popup extends google.maps.OverlayView {
    constructor(position, content) {
      super();
      _defineProperty(this, "position", void 0);
      _defineProperty(this, "content", void 0);
      this.position = new globalThis.google.maps.LatLng(position);
      this.content = content;

      // Optionally stop clicks, etc., from bubbling up to the map.
      Popup.preventMapHitsAndGesturesFrom(this.content);
    }

    /** Called when the popup is added to the map. */
    onAdd() {
      const panes = this.getPanes();
      this.content.addEventListener('touchstart', () => null, {
        passive: true
      });
      this.content.addEventListener('touchmove', () => null, {
        passive: true
      });
      if (panes) panes.floatPane.appendChild(this.content);
    }

    /** Called when the popup is removed from the map. */
    onRemove() {
      if (this.content.parentElement) this.content.parentElement.removeChild(this.content);
    }

    /** Called each frame when the popup needs to draw itself. */
    // TODO: This is called soooo much
    draw() {
      const projection = this.getProjection();
      if (!projection) return this.onRemove();
      const divPosition = projection.fromLatLngToDivPixel(this.position);

      // Hide the popup when it is far out of view.
      // TODO: Make this a prop
      const display = divPosition && Math.abs(divPosition.x) < 4000 && Math.abs(divPosition.y) < 4000 ? 'block' : 'none';
      if (display === 'block') {
        this.content.style.left = divPosition.x + 'px';
        this.content.style.top = divPosition.y + 'px';
      }
      if (this.content.style.display !== display) {
        this.content.style.display = display;
      }
    }

    // Custom
    setPosition(position) {
      this.position = new globalThis.google.maps.LatLng(position);
      this.draw();
    }
  };
};var _dec$9, _dec2$9, _dec3$9, _dec4$9, _dec5$7, _class$9, _class2$9, _descriptor$9, _descriptor2$9, _descriptor3$9, _descriptor4$6;
let GmapsClusterPin = (_dec$9 = vuePropertyDecorator.Inject('getMap'), _dec2$9 = vuePropertyDecorator.Prop({
  required: true
}), _dec3$9 = vuePropertyDecorator.Prop({
  required: true
}), _dec4$9 = vuePropertyDecorator.Prop({
  default: '#EEEEEE'
}), _dec5$7 = vuePropertyDecorator.Watch('position', {
  deep: true
}), vuePropertyDecorator.Component(_class$9 = (_class2$9 = class GmapsClusterPin extends vuePropertyDecorator.Vue {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", 'gmapsClusterPin');
    _initializerDefineProperty(this, "getMap", _descriptor$9, this);
    _initializerDefineProperty(this, "position", _descriptor2$9, this);
    _initializerDefineProperty(this, "count", _descriptor3$9, this);
    _initializerDefineProperty(this, "background", _descriptor4$6, this);
    _defineProperty(this, "popup", void 0);
  }
  positionChanged(newVal) {
    if (this.popup) this.popup.setPosition(newVal);
  }
  mounted() {
    const Popup = createPopupClass();
    this.popup = new Popup(this.position, this.$el);
    if (this.popup) this.popup.setMap(this.getMap());
  }
  beforeDestroy() {
    if (this.popup) this.popup.setMap(null);
  }
  render() {
    return null;
  }
}, (_descriptor$9 = _applyDecoratedDescriptor(_class2$9.prototype, "getMap", [_dec$9], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2$9 = _applyDecoratedDescriptor(_class2$9.prototype, "position", [_dec2$9], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3$9 = _applyDecoratedDescriptor(_class2$9.prototype, "count", [_dec3$9], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4$6 = _applyDecoratedDescriptor(_class2$9.prototype, "background", [_dec4$9], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _applyDecoratedDescriptor(_class2$9.prototype, "positionChanged", [_dec5$7], Object.getOwnPropertyDescriptor(_class2$9.prototype, "positionChanged"), _class2$9.prototype)), _class2$9)) || _class$9);/* script */
const __vue_script__$2 = GmapsClusterPin;

/* template */
var __vue_render__$2 = function () {
  var _obj;
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c('div', {
    staticClass: "gmaps-cluster-pin",
    on: {
      "click": function ($event) {
        $event.preventDefault();
        return _vm.$emit('click');
      }
    }
  }, [_vm._ssrNode("<div class=\"gmaps-cluster-center\"" + _vm._ssrStyle(null, (_obj = {}, _obj['--background'] = _vm.background, _obj), null) + "><span>" + _vm._ssrEscape("\n      " + _vm._s(_vm.count) + "\n    ") + "</span></div>")]);
};
var __vue_staticRenderFns__$2 = [];

/* style */
const __vue_inject_styles__$2 = function (inject) {
  if (!inject) return;
  inject("data-v-4973b532_0", {
    source: ".gmaps-cluster-center{color:#444;cursor:pointer;font-family:sans-serif;font-size:18px;left:0;overflow-y:auto;padding:5px;position:absolute;text-align:center;vertical-align:middle;top:0;transform:translate(-50%,-100%);min-width:40px;border-radius:50%;background-color:var(--background);box-shadow:0 0 10px 10px var(--background);pointer-events:all}.gmaps-cluster-pin{pointer-events:none;cursor:auto;height:0;position:absolute;width:100%}",
    map: undefined,
    media: undefined
  });
};
/* scoped */
const __vue_scope_id__$2 = undefined;
/* module identifier */
const __vue_module_identifier__$2 = "data-v-4973b532";
/* functional template */
const __vue_is_functional_template__$2 = false;
/* style inject shadow dom */

const __vue_component__$2 = /*#__PURE__*/normalizeComponent({
  render: __vue_render__$2,
  staticRenderFns: __vue_staticRenderFns__$2
}, __vue_inject_styles__$2, __vue_script__$2, __vue_scope_id__$2, __vue_is_functional_template__$2, __vue_module_identifier__$2, false, undefined, createInjectorSSR, undefined);var _dec$8, _dec2$8, _dec3$8, _dec4$8, _dec5$6, _dec6$5, _dec7$4, _class$8, _class2$8, _descriptor$8, _descriptor2$8, _descriptor3$8, _descriptor4$5;
const defaultOptions = {
  minZoom: -1,
  maxZoom: 8,
  tileSize: 0.4,
  // TODO: Seems to break the click to zoom above this number??
  highPercentage: 10,
  lowPercentage: 3
};
let GmapsCluster = (_dec$8 = vuePropertyDecorator.Component({
  components: {
    gmapsMarker: GmapsMarker,
    gmapsClusterPin: __vue_component__$2
  }
}), _dec2$8 = vuePropertyDecorator.Inject('getMap'), _dec3$8 = vuePropertyDecorator.Prop({
  default: true
}), _dec4$8 = vuePropertyDecorator.Prop({
  required: true
}), _dec5$6 = vuePropertyDecorator.Prop({
  default: () => ({})
}), _dec6$5 = vuePropertyDecorator.Watch('options', {
  immediate: true
}), _dec7$4 = vuePropertyDecorator.Watch('items', {
  immediate: true
}), _dec$8(_class$8 = (_class2$8 = class GmapsCluster extends vuePropertyDecorator.Vue {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", 'gmapsCluster');
    _initializerDefineProperty(this, "getMap", _descriptor$8, this);
    _initializerDefineProperty(this, "zoomOnClick", _descriptor2$8, this);
    _initializerDefineProperty(this, "items", _descriptor3$8, this);
    _initializerDefineProperty(this, "options", _descriptor4$5, this);
    _defineProperty(this, "clusterOptions", {
      ...defaultOptions
    });
    _defineProperty(this, "eventListener", []);
    _defineProperty(this, "all", {});
    _defineProperty(this, "clusters", {});
    _defineProperty(this, "clustered", false);
  }
  optionsChanged(newOptions) {
    this.clusterOptions = {
      ...defaultOptions,
      ...newOptions
    };
    this.handleZoom();
    this.handlePan();
  }
  itemsChanged() {
    this.handleZoom();
    this.handlePan();
  }
  handlePan() {
    const _bounds = this.getMap().getBounds();
    if (!_bounds) return;
    const _newbounds = extendBounds(_bounds);
    const _filtered = {};
    const _rand = Math.floor(Math.random() * 10000);
    for (const [key, value] of Object.entries(this.all)) if (_newbounds !== null && _newbounds !== void 0 && _newbounds.contains(value.pos)) _filtered[`${key}-${_rand}`] = value;
    this.clusters = _filtered;
  }
  handleZoom() {
    const _zoom = this.getMap().getZoom();
    this.all = organiseClusters(this.items, Math.max(_zoom, this.clusterOptions.minZoom), this.clusterOptions.maxZoom, this.clusterOptions.tileSize);
  }
  getColor(weight) {
    if (weight === undefined) return;
    if (!this.clusterOptions.highPercentage && !this.clusterOptions.lowPercentage) return;
    if (this.clusterOptions.highPercentage && weight >= this.clusterOptions.highPercentage) return '#FBB3BD';
    if (this.clusterOptions.lowPercentage && weight <= this.clusterOptions.lowPercentage) return '#CCF1FF';
    return '#F1E0B0';
  }
  clusterClickHandler(key) {
    if (this.zoomOnClick) {
      const _clusterBounds = getBounds(this.clusters[key].items);
      this.getMap().fitBounds(_clusterBounds);
    } else {
      this.$emit('click', this.clusters[key]);
    }
  }
  mounted() {
    this.handleZoom();
    this.eventListener.push(this.getMap().addListener('idle', () => this.handlePan()), this.getMap().addListener('zoom_changed', () => this.handleZoom()));
  }
  beforeDestroy() {
    if (this.eventListener.length) this.eventListener.forEach(e => e.remove());
  }
}, (_descriptor$8 = _applyDecoratedDescriptor(_class2$8.prototype, "getMap", [_dec2$8], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2$8 = _applyDecoratedDescriptor(_class2$8.prototype, "zoomOnClick", [_dec3$8], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3$8 = _applyDecoratedDescriptor(_class2$8.prototype, "items", [_dec4$8], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4$5 = _applyDecoratedDescriptor(_class2$8.prototype, "options", [_dec5$6], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _applyDecoratedDescriptor(_class2$8.prototype, "optionsChanged", [_dec6$5], Object.getOwnPropertyDescriptor(_class2$8.prototype, "optionsChanged"), _class2$8.prototype), _applyDecoratedDescriptor(_class2$8.prototype, "itemsChanged", [_dec7$4], Object.getOwnPropertyDescriptor(_class2$8.prototype, "itemsChanged"), _class2$8.prototype)), _class2$8)) || _class$8);/* script */
const __vue_script__$1 = GmapsCluster;

/* template */
var __vue_render__$1 = function () {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c('div', [_vm._l(_vm.clusters, function (ref, key) {
    var pos = ref.pos;
    var items = ref.items;
    var weight = ref.weight;
    return [items.length > 1 ? _c('gmaps-cluster-pin', {
      key: "c-" + key,
      attrs: {
        "count": items.length,
        "position": pos,
        "background": _vm.getColor(weight)
      },
      on: {
        "click": function ($event) {
          return _vm.clusterClickHandler(key);
        }
      }
    }) : _c('gmaps-marker', {
      key: "m-" + key,
      attrs: {
        "position": pos,
        "title": items[0].title || items[0].id,
        "visible": items[0].visible,
        "icon": items[0].icon,
        "label": items[0].label,
        "opacity": items[0].opacity,
        "z-index": items[0].zIndex,
        "options": items[0].options
      },
      on: {
        "click": function ($event) {
          return _vm.$emit('click', items[0].id || $event);
        }
      }
    })];
  })], 2);
};
var __vue_staticRenderFns__$1 = [];

/* style */
const __vue_inject_styles__$1 = undefined;
/* scoped */
const __vue_scope_id__$1 = undefined;
/* module identifier */
const __vue_module_identifier__$1 = "data-v-1325ae81";
/* functional template */
const __vue_is_functional_template__$1 = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

const __vue_component__$1 = /*#__PURE__*/normalizeComponent({
  render: __vue_render__$1,
  staticRenderFns: __vue_staticRenderFns__$1
}, __vue_inject_styles__$1, __vue_script__$1, __vue_scope_id__$1, __vue_is_functional_template__$1, __vue_module_identifier__$1, false, undefined, undefined, undefined);var _dec$7, _dec2$7, _dec3$7, _dec4$7, _class$7, _class2$7, _descriptor$7, _descriptor2$7, _descriptor3$7;
let GmapsData = (_dec$7 = vuePropertyDecorator.Inject('getMap'), _dec2$7 = vuePropertyDecorator.Inject('handleError'), _dec3$7 = vuePropertyDecorator.Prop({
  default: undefined
}), _dec4$7 = vuePropertyDecorator.Watch('options', {
  immediate: true,
  deep: true
}), vuePropertyDecorator.Component(_class$7 = (_class2$7 = class GmapsData extends vuePropertyDecorator.Vue {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", 'gmapsData');
    _initializerDefineProperty(this, "getMap", _descriptor$7, this);
    _initializerDefineProperty(this, "handleError", _descriptor2$7, this);
    _initializerDefineProperty(this, "options", _descriptor3$7, this);
  }
  optionsChanged(newVal) {
    this.getMap().data.setStyle(newVal);
  }
  mounted() {
    // NOTE: This is to enforce only one GmapsData element per map
    if (this.getMap().data.getFeatureById('_gmapsDataCollection')) return this.handleError(new Error('There can only be one GmapsData element per GmapsMap. Use GmapsDataGeoJson elements to add more GeoJSON data.'));
    this.getMap().data.add(new globalThis.google.maps.Data.Feature({
      id: '_gmapsDataCollection'
    }));
    // NOTE: Events occur on the whole data object, not individual features
    this.getMap().data.addListener('click', e => this.$emit('click', e));
    this.getMap().data.addListener('contextmenu', e => this.$emit('contextmenu', e));
    this.getMap().data.addListener('dblclick', e => this.$emit('dblclick', e));
    this.getMap().data.addListener('mousedown', e => this.$emit('mousedown', e));
    this.getMap().data.addListener('mouseout', e => this.$emit('mouseout', e));
    this.getMap().data.addListener('mouseover', e => this.$emit('mouseover', e));
    this.getMap().data.addListener('mouseup', e => this.$emit('mouseup', e));
    this.getMap().data.addListener('rightclick', e => this.$emit('rightclick', e));
  }
  beforeDestroy() {
    const mainFeature = this.getMap().data.getFeatureById('_gmapsDataCollection');
    if (mainFeature) this.getMap().data.remove(mainFeature);
  }
  render(h) {
    return h('div', this.$slots.default);
  }
}, (_descriptor$7 = _applyDecoratedDescriptor(_class2$7.prototype, "getMap", [_dec$7], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2$7 = _applyDecoratedDescriptor(_class2$7.prototype, "handleError", [_dec2$7], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3$7 = _applyDecoratedDescriptor(_class2$7.prototype, "options", [_dec3$7], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _applyDecoratedDescriptor(_class2$7.prototype, "optionsChanged", [_dec4$7], Object.getOwnPropertyDescriptor(_class2$7.prototype, "optionsChanged"), _class2$7.prototype)), _class2$7)) || _class$7);var _dec$6, _dec2$6, _dec3$6, _dec4$6, _dec5$5, _class$6, _class2$6, _descriptor$6, _descriptor2$6, _descriptor3$6;
let GmapsDataGeoJson = (_dec$6 = vuePropertyDecorator.Inject('getMap'), _dec2$6 = vuePropertyDecorator.Prop({
  default: undefined
}), _dec3$6 = vuePropertyDecorator.Prop({
  default: undefined
}), _dec4$6 = vuePropertyDecorator.Watch('geoJson', {
  immediate: true,
  deep: true
}), _dec5$5 = vuePropertyDecorator.Watch('styleOptions', {
  immediate: true,
  deep: true
}), vuePropertyDecorator.Component(_class$6 = (_class2$6 = class GmapsDataGeoJson extends vuePropertyDecorator.Vue {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", 'gmapsDataGeoJson');
    _initializerDefineProperty(this, "getMap", _descriptor$6, this);
    _initializerDefineProperty(this, "options", _descriptor2$6, this);
    _initializerDefineProperty(this, "geoJson", _descriptor3$6, this);
    _defineProperty(this, "features", []);
  }
  updateGeoJson() {
    // Clear feature list
    this.clear();
    if (!this.geoJson) return;
    // Add whatever was given and store returned features
    this.features = this.getMap().data.addGeoJson(this.geoJson);
    this.updateStyles();
  }
  updateStyles() {
    this.features.forEach(e => this.getMap().data.overrideStyle(e, this.options));
  }
  clear() {
    // TODO: Test whether this function can handle removing non-existent features
    this.features.forEach(e => this.getMap().data.remove(e));
  }
  _geoJsonChanged() {
    this.updateGeoJson();
  }
  _styleOptionsChanged() {
    this.updateStyles();
  }
  mounted() {
    this.updateGeoJson();
  }
  beforeDestroy() {
    this.clear();
  }
  render() {
    return null;
  }
}, (_descriptor$6 = _applyDecoratedDescriptor(_class2$6.prototype, "getMap", [_dec$6], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2$6 = _applyDecoratedDescriptor(_class2$6.prototype, "options", [_dec2$6], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3$6 = _applyDecoratedDescriptor(_class2$6.prototype, "geoJson", [_dec3$6], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _applyDecoratedDescriptor(_class2$6.prototype, "_geoJsonChanged", [_dec4$6], Object.getOwnPropertyDescriptor(_class2$6.prototype, "_geoJsonChanged"), _class2$6.prototype), _applyDecoratedDescriptor(_class2$6.prototype, "_styleOptionsChanged", [_dec5$5], Object.getOwnPropertyDescriptor(_class2$6.prototype, "_styleOptionsChanged"), _class2$6.prototype)), _class2$6)) || _class$6);var _dec$5, _dec2$5, _dec3$5, _dec4$5, _class$5, _class2$5, _descriptor$5, _descriptor2$5, _descriptor3$5;
let GmapsInfoWindow = (_dec$5 = vuePropertyDecorator.Inject('getMap'), _dec2$5 = vuePropertyDecorator.Inject('handleError'), _dec3$5 = vuePropertyDecorator.Prop({
  default: () => ({})
}), _dec4$5 = vuePropertyDecorator.Watch('options', {
  immediate: true,
  deep: true
}), vuePropertyDecorator.Component(_class$5 = (_class2$5 = class GmapsInfoWindow extends vuePropertyDecorator.Vue {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", 'gmapsInfoWindow');
    _initializerDefineProperty(this, "getMap", _descriptor$5, this);
    _initializerDefineProperty(this, "handleError", _descriptor2$5, this);
    _initializerDefineProperty(this, "options", _descriptor3$5, this);
    _defineProperty(this, "infoW", void 0);
  }
  open() {
    if (this.infoW) this.infoW.open(this.getMap());
  }
  optionsChanged(newVal) {
    if (this.infoW) this.infoW.setOptions(newVal);
  }
  mounted() {
    if (!this.options.position) return this.handleError(new Error('InfoWindow options require a position property.'));
    this.infoW = new globalThis.google.maps.InfoWindow({
      content: this.$el,
      ...this.options
    });
    this.infoW.addListener('closeclick', () => this.$emit('closed'));
    this.open();
  }
  beforeDestroy() {
    if (this.infoW) this.infoW.close();
    if (this.infoW) globalThis.google.maps.event.clearInstanceListeners(this.infoW);
  }
  render(h) {
    return h('div', this.$slots.default);
  }
}, (_descriptor$5 = _applyDecoratedDescriptor(_class2$5.prototype, "getMap", [_dec$5], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2$5 = _applyDecoratedDescriptor(_class2$5.prototype, "handleError", [_dec2$5], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3$5 = _applyDecoratedDescriptor(_class2$5.prototype, "options", [_dec3$5], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _applyDecoratedDescriptor(_class2$5.prototype, "optionsChanged", [_dec4$5], Object.getOwnPropertyDescriptor(_class2$5.prototype, "optionsChanged"), _class2$5.prototype)), _class2$5)) || _class$5);var _dec$4, _dec2$4, _dec3$4, _dec4$4, _dec5$4, _dec6$4, _dec7$3, _dec8$3, _dec9$3, _dec10$2, _dec11$2, _dec12$2, _dec13$2, _dec14$2, _dec15$1, _dec16, _class$4, _class2$4, _descriptor$4, _descriptor2$4, _descriptor3$4, _descriptor4$4, _descriptor5$4, _descriptor6$3, _descriptor7$3, _descriptor8$3, _descriptor9$2, _descriptor10$2, _descriptor11$2, _descriptor12$2, _descriptor13$2, _descriptor14$1, _descriptor15;
let GmapsPolygon = (_dec$4 = vuePropertyDecorator.Inject('getMap'), _dec2$4 = vuePropertyDecorator.Prop({
  default: () => ({})
}), _dec3$4 = vuePropertyDecorator.Prop({
  default: true
}), _dec4$4 = vuePropertyDecorator.Prop({
  default: false
}), _dec5$4 = vuePropertyDecorator.Prop({
  default: false
}), _dec6$4 = vuePropertyDecorator.Prop({
  default: 'black'
}), _dec7$3 = vuePropertyDecorator.Prop({
  default: 0.3
}), _dec8$3 = vuePropertyDecorator.Prop({
  default: false
}), _dec9$3 = vuePropertyDecorator.Prop({
  required: true
}), _dec10$2 = vuePropertyDecorator.Prop({
  default: 'black'
}), _dec11$2 = vuePropertyDecorator.Prop({
  default: 1.0
}), _dec12$2 = vuePropertyDecorator.Prop({
  default: 0
}), _dec13$2 = vuePropertyDecorator.Prop({
  default: 3
}), _dec14$2 = vuePropertyDecorator.Prop({
  default: true
}), _dec15$1 = vuePropertyDecorator.Prop({
  default: 0
}), _dec16 = vuePropertyDecorator.Watch('_options', {
  immediate: true,
  deep: true
}), vuePropertyDecorator.Component(_class$4 = (_class2$4 = class GmapsPolygon extends vuePropertyDecorator.Vue {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", 'gmapsPolygon');
    _initializerDefineProperty(this, "getMap", _descriptor$4, this);
    _initializerDefineProperty(this, "options", _descriptor2$4, this);
    _initializerDefineProperty(this, "clickable", _descriptor3$4, this);
    _initializerDefineProperty(this, "draggable", _descriptor4$4, this);
    _initializerDefineProperty(this, "editable", _descriptor5$4, this);
    _initializerDefineProperty(this, "fillColor", _descriptor6$3, this);
    _initializerDefineProperty(this, "fillOpacity", _descriptor7$3, this);
    _initializerDefineProperty(this, "geodesic", _descriptor8$3, this);
    _initializerDefineProperty(this, "path", _descriptor9$2, this);
    _initializerDefineProperty(this, "strokeColor", _descriptor10$2, this);
    _initializerDefineProperty(this, "strokeOpacity", _descriptor11$2, this);
    _initializerDefineProperty(this, "strokePosition", _descriptor12$2, this);
    _initializerDefineProperty(this, "strokeWeight", _descriptor13$2, this);
    _initializerDefineProperty(this, "visible", _descriptor14$1, this);
    _initializerDefineProperty(this, "zIndex", _descriptor15, this);
    _defineProperty(this, "polygon", void 0);
  }
  get _options() {
    const options = {
      ...this.options,
      geodesic: this.geodesic,
      paths: [this.path],
      clickable: this.clickable,
      draggable: this.draggable,
      editable: this.editable,
      fillColor: this.fillColor,
      fillOpacity: +this.fillOpacity,
      strokeColor: this.strokeColor,
      strokeOpacity: +this.strokeOpacity,
      strokePosition: +this.strokePosition,
      strokeWeight: +this.strokeWeight,
      visible: this.visible,
      zIndex: +this.zIndex
    };
    return options;
  }
  _optionsChanged(newVal) {
    if (this.polygon) this.polygon.setOptions(newVal);
  }
  changedPath() {
    if (this.polygon && (this.polygon.getEditable() || this.polygon.getDraggable())) {
      const result = this.polygon.getPath().getArray().map(e => e.toJSON());
      this.polygon.setPath(result);
      this.$emit('path-changed', result);
      // TODO: Remove in major release
      this.$emit('pathChanged', result); // eslint-disable-line
    }
  }

  mounted() {
    this.polygon = new globalThis.google.maps.Polygon({
      map: this.getMap(),
      ...this._options
    });
    this.polygon.addListener('click', e => this.$emit('click', e));
    this.polygon.addListener('dblclick', e => this.$emit('double-click', e));
    this.polygon.addListener('dragend', e => this.$emit('drag-end', e));
    this.polygon.addListener('dragstart', e => this.$emit('drag-start', e));
    this.polygon.addListener('rightclick', e => this.$emit('right-click', e));
    // NOTE: path events insert_at and set_at only fired once so mouse up was more reliable (but mouse up doesn't trigger for remove event)
    this.polygon.addListener('mouseup', () => this.changedPath());
    this.polygon.getPath().addListener('remove_at', () => this.changedPath());
    // TODO: Remove in major release
    this.polygon.addListener('dblclick', e => this.$emit('doubleClick', e)); // eslint-disable-line
    this.polygon.addListener('dragend', e => this.$emit('dragEnd', e)); // eslint-disable-line
    this.polygon.addListener('dragstart', e => this.$emit('dragStart', e)); // eslint-disable-line
    this.polygon.addListener('rightclick', e => this.$emit('rightClick', e)); // eslint-disable-line
  }

  beforeDestroy() {
    if (this.polygon) this.polygon.setMap(null);
  }
  render() {
    return null;
  }
}, (_descriptor$4 = _applyDecoratedDescriptor(_class2$4.prototype, "getMap", [_dec$4], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2$4 = _applyDecoratedDescriptor(_class2$4.prototype, "options", [_dec2$4], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3$4 = _applyDecoratedDescriptor(_class2$4.prototype, "clickable", [_dec3$4], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4$4 = _applyDecoratedDescriptor(_class2$4.prototype, "draggable", [_dec4$4], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor5$4 = _applyDecoratedDescriptor(_class2$4.prototype, "editable", [_dec5$4], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor6$3 = _applyDecoratedDescriptor(_class2$4.prototype, "fillColor", [_dec6$4], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor7$3 = _applyDecoratedDescriptor(_class2$4.prototype, "fillOpacity", [_dec7$3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor8$3 = _applyDecoratedDescriptor(_class2$4.prototype, "geodesic", [_dec8$3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor9$2 = _applyDecoratedDescriptor(_class2$4.prototype, "path", [_dec9$3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor10$2 = _applyDecoratedDescriptor(_class2$4.prototype, "strokeColor", [_dec10$2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor11$2 = _applyDecoratedDescriptor(_class2$4.prototype, "strokeOpacity", [_dec11$2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor12$2 = _applyDecoratedDescriptor(_class2$4.prototype, "strokePosition", [_dec12$2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor13$2 = _applyDecoratedDescriptor(_class2$4.prototype, "strokeWeight", [_dec13$2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor14$1 = _applyDecoratedDescriptor(_class2$4.prototype, "visible", [_dec14$2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor15 = _applyDecoratedDescriptor(_class2$4.prototype, "zIndex", [_dec15$1], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _applyDecoratedDescriptor(_class2$4.prototype, "_optionsChanged", [_dec16], Object.getOwnPropertyDescriptor(_class2$4.prototype, "_optionsChanged"), _class2$4.prototype)), _class2$4)) || _class$4);var _dec$3, _dec2$3, _dec3$3, _dec4$3, _dec5$3, _dec6$3, _dec7$2, _dec8$2, _dec9$2, _dec10$1, _dec11$1, _dec12$1, _dec13$1, _dec14$1, _class$3, _class2$3, _descriptor$3, _descriptor2$3, _descriptor3$3, _descriptor4$3, _descriptor5$3, _descriptor6$2, _descriptor7$2, _descriptor8$2, _descriptor9$1, _descriptor10$1, _descriptor11$1, _descriptor12$1, _descriptor13$1;
let GmapsPolyline = (_dec$3 = vuePropertyDecorator.Inject('getMap'), _dec2$3 = vuePropertyDecorator.Prop({
  default: () => ({})
}), _dec3$3 = vuePropertyDecorator.Prop({
  default: true
}), _dec4$3 = vuePropertyDecorator.Prop({
  default: false
}), _dec5$3 = vuePropertyDecorator.Prop({
  default: false
}), _dec6$3 = vuePropertyDecorator.Prop({
  default: undefined
}), _dec7$2 = vuePropertyDecorator.Prop({
  default: false
}), _dec8$2 = vuePropertyDecorator.Prop({
  required: true
}), _dec9$2 = vuePropertyDecorator.Prop({
  default: 'black'
}), _dec10$1 = vuePropertyDecorator.Prop({
  default: 1.0
}), _dec11$1 = vuePropertyDecorator.Prop({
  default: 3
}), _dec12$1 = vuePropertyDecorator.Prop({
  default: true
}), _dec13$1 = vuePropertyDecorator.Prop({
  default: 0
}), _dec14$1 = vuePropertyDecorator.Watch('_options', {
  immediate: true,
  deep: true
}), vuePropertyDecorator.Component(_class$3 = (_class2$3 = class GmapsPolyline extends vuePropertyDecorator.Vue {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", 'gmapsPolyline');
    _initializerDefineProperty(this, "getMap", _descriptor$3, this);
    _initializerDefineProperty(this, "options", _descriptor2$3, this);
    _initializerDefineProperty(this, "clickable", _descriptor3$3, this);
    _initializerDefineProperty(this, "draggable", _descriptor4$3, this);
    _initializerDefineProperty(this, "editable", _descriptor5$3, this);
    _initializerDefineProperty(this, "icons", _descriptor6$2, this);
    _initializerDefineProperty(this, "geodesic", _descriptor7$2, this);
    _initializerDefineProperty(this, "path", _descriptor8$2, this);
    _initializerDefineProperty(this, "strokeColor", _descriptor9$1, this);
    _initializerDefineProperty(this, "strokeOpacity", _descriptor10$1, this);
    _initializerDefineProperty(this, "strokeWeight", _descriptor11$1, this);
    _initializerDefineProperty(this, "visible", _descriptor12$1, this);
    _initializerDefineProperty(this, "zIndex", _descriptor13$1, this);
    _defineProperty(this, "polyline", void 0);
  }
  get _options() {
    const options = {
      ...this.options,
      geodesic: this.geodesic,
      path: this.path,
      clickable: this.clickable,
      draggable: this.draggable,
      editable: this.editable,
      strokeColor: this.strokeColor,
      strokeOpacity: +this.strokeOpacity,
      strokeWeight: +this.strokeWeight,
      visible: this.visible,
      zIndex: +this.zIndex
    };
    if (this.icons) options.icons = this.icons;
    return options;
  }
  _optionsChanged(newVal) {
    if (this.polyline) this.polyline.setOptions(newVal);
  }
  changedPath() {
    if (this.polyline && (this.polyline.getEditable() || this.polyline.getDraggable())) {
      const result = this.polyline.getPath().getArray().map(e => e.toJSON());
      this.polyline.setPath(result);
      this.$emit('path-changed', result);
      // TODO: Remove in major release
      this.$emit('pathChanged', result); // eslint-disable-line
    }
  }

  mounted() {
    this.polyline = new globalThis.google.maps.Polyline({
      map: this.getMap(),
      ...this._options
    });
    this.polyline.addListener('click', e => this.$emit('click', e));
    this.polyline.addListener('dblclick', e => this.$emit('double-click', e));
    this.polyline.addListener('dragend', e => this.$emit('drag-end', e));
    this.polyline.addListener('dragstart', e => this.$emit('drag-start', e));
    this.polyline.addListener('rightclick', e => this.$emit('right-click', e));
    // NOTE: path events insert_at and set_at only fired once so mouse up was more reliable (but mouse up doesn't trigger for remove event)
    this.polyline.addListener('mouseup', () => this.changedPath());
    this.polyline.getPath().addListener('remove_at', () => this.changedPath());
    // TODO: Remove in major release
    this.polyline.addListener('dblclick', e => this.$emit('doubleClick', e)); // eslint-disable-line
    this.polyline.addListener('dragend', e => this.$emit('dragEnd', e)); // eslint-disable-line
    this.polyline.addListener('dragstart', e => this.$emit('dragStart', e)); // eslint-disable-line
    this.polyline.addListener('rightclick', e => this.$emit('rightClick', e)); // eslint-disable-line
  }

  beforeDestroy() {
    if (this.polyline) this.polyline.setMap(null);
  }
  render() {
    return null;
  }
}, (_descriptor$3 = _applyDecoratedDescriptor(_class2$3.prototype, "getMap", [_dec$3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2$3 = _applyDecoratedDescriptor(_class2$3.prototype, "options", [_dec2$3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3$3 = _applyDecoratedDescriptor(_class2$3.prototype, "clickable", [_dec3$3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4$3 = _applyDecoratedDescriptor(_class2$3.prototype, "draggable", [_dec4$3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor5$3 = _applyDecoratedDescriptor(_class2$3.prototype, "editable", [_dec5$3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor6$2 = _applyDecoratedDescriptor(_class2$3.prototype, "icons", [_dec6$3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor7$2 = _applyDecoratedDescriptor(_class2$3.prototype, "geodesic", [_dec7$2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor8$2 = _applyDecoratedDescriptor(_class2$3.prototype, "path", [_dec8$2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor9$1 = _applyDecoratedDescriptor(_class2$3.prototype, "strokeColor", [_dec9$2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor10$1 = _applyDecoratedDescriptor(_class2$3.prototype, "strokeOpacity", [_dec10$1], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor11$1 = _applyDecoratedDescriptor(_class2$3.prototype, "strokeWeight", [_dec11$1], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor12$1 = _applyDecoratedDescriptor(_class2$3.prototype, "visible", [_dec12$1], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor13$1 = _applyDecoratedDescriptor(_class2$3.prototype, "zIndex", [_dec13$1], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _applyDecoratedDescriptor(_class2$3.prototype, "_optionsChanged", [_dec14$1], Object.getOwnPropertyDescriptor(_class2$3.prototype, "_optionsChanged"), _class2$3.prototype)), _class2$3)) || _class$3);var _dec$2, _dec2$2, _dec3$2, _dec4$2, _dec5$2, _dec6$2, _class$2, _class2$2, _descriptor$2, _descriptor2$2, _descriptor3$2, _descriptor4$2, _descriptor5$2;
let GmapsPopup = (_dec$2 = vuePropertyDecorator.Inject('getMap'), _dec2$2 = vuePropertyDecorator.Prop({
  required: true
}), _dec3$2 = vuePropertyDecorator.Prop({
  default: '#EEEEEE'
}), _dec4$2 = vuePropertyDecorator.Prop({
  default: '200px'
}), _dec5$2 = vuePropertyDecorator.Prop({
  default: '60px'
}), _dec6$2 = vuePropertyDecorator.Watch('position', {
  deep: true
}), vuePropertyDecorator.Component(_class$2 = (_class2$2 = class GmapsPopup extends vuePropertyDecorator.Vue {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", 'gmapsPopup');
    _initializerDefineProperty(this, "getMap", _descriptor$2, this);
    _initializerDefineProperty(this, "position", _descriptor2$2, this);
    _initializerDefineProperty(this, "background", _descriptor3$2, this);
    _initializerDefineProperty(this, "width", _descriptor4$2, this);
    _initializerDefineProperty(this, "height", _descriptor5$2, this);
    _defineProperty(this, "popup", void 0);
  }
  positionChanged(newVal) {
    if (this.popup) this.popup.setPosition(newVal);
  }
  mounted() {
    const Popup = createPopupClass();
    this.popup = new Popup(this.position, this.$el);
    if (this.popup) this.popup.setMap(this.getMap());
  }
  beforeDestroy() {
    if (this.popup) this.popup.setMap(null);
  }
}, (_descriptor$2 = _applyDecoratedDescriptor(_class2$2.prototype, "getMap", [_dec$2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2$2 = _applyDecoratedDescriptor(_class2$2.prototype, "position", [_dec2$2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3$2 = _applyDecoratedDescriptor(_class2$2.prototype, "background", [_dec3$2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4$2 = _applyDecoratedDescriptor(_class2$2.prototype, "width", [_dec4$2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor5$2 = _applyDecoratedDescriptor(_class2$2.prototype, "height", [_dec5$2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _applyDecoratedDescriptor(_class2$2.prototype, "positionChanged", [_dec6$2], Object.getOwnPropertyDescriptor(_class2$2.prototype, "positionChanged"), _class2$2.prototype)), _class2$2)) || _class$2);/* script */
const __vue_script__ = GmapsPopup;

/* template */
var __vue_render__ = function () {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c('div', {
    staticClass: "gmaps-popup-container",
    on: {
      "click": function ($event) {
        $event.preventDefault();
        return _vm.$emit('click');
      }
    }
  }, [_vm._ssrNode("<div class=\"gmaps-popup-bubble-anchor\"" + _vm._ssrStyle(null, "color: " + _vm.background + ";", null) + ">", "</div>", [_vm._ssrNode("<div class=\"gmaps-popup-bubble\"" + _vm._ssrStyle(null, {
    background: _vm.background,
    maxWidth: _vm.width,
    maxHeight: _vm.height
  }, null) + ">", "</div>", [_vm._t("default")], 2)])]);
};
var __vue_staticRenderFns__ = [];

/* style */
const __vue_inject_styles__ = function (inject) {
  if (!inject) return;
  inject("data-v-5627b1f1_0", {
    source: ".gmaps-popup-bubble{border-radius:5px;box-shadow:0 3px 10px 1px rgba(0,0,0,.5);color:#444;cursor:pointer;font-family:sans-serif;left:0;overflow-y:auto;padding:5px;position:absolute;top:0;transform:translate(-50%,-100%)}.gmaps-popup-bubble-anchor{bottom:8px;left:0;position:absolute;width:100%}.gmaps-popup-bubble-anchor::after{border-left:6px solid transparent;border-right:6px solid transparent;border-top:8px solid;border-top-color:inherit!important;content:\"\";height:0;left:0;position:absolute;top:-1px;transform:translate(-50%,0);width:0;cursor:pointer}.gmaps-popup-container{cursor:auto;height:0;position:absolute;width:100%}",
    map: undefined,
    media: undefined
  });
};
/* scoped */
const __vue_scope_id__ = undefined;
/* module identifier */
const __vue_module_identifier__ = "data-v-5627b1f1";
/* functional template */
const __vue_is_functional_template__ = false;
/* style inject shadow dom */

const __vue_component__ = /*#__PURE__*/normalizeComponent({
  render: __vue_render__,
  staticRenderFns: __vue_staticRenderFns__
}, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, false, undefined, createInjectorSSR, undefined);var _dec$1, _dec2$1, _dec3$1, _dec4$1, _dec5$1, _dec6$1, _dec7$1, _dec8$1, _dec9$1, _class$1, _class2$1, _descriptor$1, _descriptor2$1, _descriptor3$1, _descriptor4$1, _descriptor5$1, _descriptor6$1, _descriptor7$1, _descriptor8$1;
let GmapsHeatmap = (_dec$1 = vuePropertyDecorator.Inject('getMap'), _dec2$1 = vuePropertyDecorator.Prop({
  default: undefined
}), _dec3$1 = vuePropertyDecorator.Prop({
  default: undefined
}), _dec4$1 = vuePropertyDecorator.Prop({
  default: 0.6
}), _dec5$1 = vuePropertyDecorator.Prop({
  default: undefined
}), _dec6$1 = vuePropertyDecorator.Prop({
  required: true
}), _dec7$1 = vuePropertyDecorator.Prop({
  default: undefined
}), _dec8$1 = vuePropertyDecorator.Prop({
  default: undefined
}), _dec9$1 = vuePropertyDecorator.Watch('_options', {
  immediate: true,
  deep: true
}), vuePropertyDecorator.Component(_class$1 = (_class2$1 = class GmapsHeatmap extends vuePropertyDecorator.Vue {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", 'gmapsHeatmap');
    _initializerDefineProperty(this, "getMap", _descriptor$1, this);
    _initializerDefineProperty(this, "dissipating", _descriptor2$1, this);
    _initializerDefineProperty(this, "maxIntensity", _descriptor3$1, this);
    _initializerDefineProperty(this, "opacity", _descriptor4$1, this);
    _initializerDefineProperty(this, "radius", _descriptor5$1, this);
    _initializerDefineProperty(this, "items", _descriptor6$1, this);
    _initializerDefineProperty(this, "colors", _descriptor7$1, this);
    _initializerDefineProperty(this, "weightProp", _descriptor8$1, this);
    _defineProperty(this, "heatmap", void 0);
  }
  getData() {
    return this.items.map(e => {
      if (this.weightProp) return {
        location: new globalThis.google.maps.LatLng(e.lat, e.lng),
        // TODO: No idea how to remove this any
        weight: e[this.weightProp]
      };
      return new globalThis.google.maps.LatLng(e.lat, e.lng);
    });
  }
  updateData() {
    if (this.heatmap) this.heatmap.setData(this.getData());
  }
  get _options() {
    const options = {
      data: this.getData()
    };
    if (this.colors) options.gradient = this.colors;
    if (this.dissipating) options.dissipating = this.dissipating;
    if (this.maxIntensity) options.maxIntensity = +this.maxIntensity;
    if (this.opacity) options.opacity = +this.opacity;
    if (this.radius) options.radius = +this.radius;
    return options;
  }
  _optionsChanged(newVal) {
    if (this.heatmap) this.heatmap.setOptions(newVal);
  }
  mounted() {
    this.heatmap = new globalThis.google.maps.visualization.HeatmapLayer({
      map: this.getMap(),
      ...this._options
    });
  }
  beforeDestroy() {
    if (this.heatmap) this.heatmap.setMap(null);
  }
  render() {
    return null;
  }
}, (_descriptor$1 = _applyDecoratedDescriptor(_class2$1.prototype, "getMap", [_dec$1], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2$1 = _applyDecoratedDescriptor(_class2$1.prototype, "dissipating", [_dec2$1], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3$1 = _applyDecoratedDescriptor(_class2$1.prototype, "maxIntensity", [_dec3$1], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4$1 = _applyDecoratedDescriptor(_class2$1.prototype, "opacity", [_dec4$1], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor5$1 = _applyDecoratedDescriptor(_class2$1.prototype, "radius", [_dec5$1], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor6$1 = _applyDecoratedDescriptor(_class2$1.prototype, "items", [_dec6$1], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor7$1 = _applyDecoratedDescriptor(_class2$1.prototype, "colors", [_dec7$1], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor8$1 = _applyDecoratedDescriptor(_class2$1.prototype, "weightProp", [_dec8$1], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _applyDecoratedDescriptor(_class2$1.prototype, "_optionsChanged", [_dec9$1], Object.getOwnPropertyDescriptor(_class2$1.prototype, "_optionsChanged"), _class2$1.prototype)), _class2$1)) || _class$1);var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _dec11, _dec12, _dec13, _dec14, _dec15, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12, _descriptor13, _descriptor14;
let GmapsRectangle = (_dec = vuePropertyDecorator.Inject('getMap'), _dec2 = vuePropertyDecorator.Prop({
  default: 0.001
}), _dec3 = vuePropertyDecorator.Prop({
  required: true
}), _dec4 = vuePropertyDecorator.Prop({
  default: true
}), _dec5 = vuePropertyDecorator.Prop({
  default: false
}), _dec6 = vuePropertyDecorator.Prop({
  default: false
}), _dec7 = vuePropertyDecorator.Prop({
  default: 'black'
}), _dec8 = vuePropertyDecorator.Prop({
  default: 0.3
}), _dec9 = vuePropertyDecorator.Prop({
  default: 'black'
}), _dec10 = vuePropertyDecorator.Prop({
  default: 1.0
}), _dec11 = vuePropertyDecorator.Prop({
  default: 0
}), _dec12 = vuePropertyDecorator.Prop({
  default: 3
}), _dec13 = vuePropertyDecorator.Prop({
  default: true
}), _dec14 = vuePropertyDecorator.Prop({
  default: 0
}), _dec15 = vuePropertyDecorator.Watch('_options', {
  immediate: true,
  deep: true
}), vuePropertyDecorator.Component(_class = (_class2 = class GmapsRectangle extends vuePropertyDecorator.Vue {
  constructor() {
    super(...arguments);
    _defineProperty(this, "name", 'gmapsRectangle');
    _initializerDefineProperty(this, "getMap", _descriptor, this);
    _initializerDefineProperty(this, "sensitivity", _descriptor2, this);
    _initializerDefineProperty(this, "bounds", _descriptor3, this);
    _initializerDefineProperty(this, "clickable", _descriptor4, this);
    _initializerDefineProperty(this, "draggable", _descriptor5, this);
    _initializerDefineProperty(this, "editable", _descriptor6, this);
    _initializerDefineProperty(this, "fillColor", _descriptor7, this);
    _initializerDefineProperty(this, "fillOpacity", _descriptor8, this);
    _initializerDefineProperty(this, "strokeColor", _descriptor9, this);
    _initializerDefineProperty(this, "strokeOpacity", _descriptor10, this);
    _initializerDefineProperty(this, "strokePosition", _descriptor11, this);
    _initializerDefineProperty(this, "strokeWeight", _descriptor12, this);
    _initializerDefineProperty(this, "visible", _descriptor13, this);
    _initializerDefineProperty(this, "zIndex", _descriptor14, this);
    _defineProperty(this, "rectangle", void 0);
    _defineProperty(this, "tempBounds", this.bounds);
  }
  get _options() {
    return {
      bounds: this.bounds,
      clickable: this.clickable,
      draggable: this.draggable,
      editable: this.editable,
      fillColor: this.fillColor,
      fillOpacity: +this.fillOpacity,
      strokeColor: this.strokeColor,
      strokeOpacity: +this.strokeOpacity,
      strokePosition: +this.strokePosition,
      strokeWeight: +this.strokeWeight,
      visible: this.visible,
      zIndex: +this.zIndex
    };
  }
  _optionsChanged(newVal) {
    if (this.rectangle) this.rectangle.setOptions(newVal);
  }
  changedBounds() {
    if (!this.rectangle) return;
    // This is fired when the component is replaced and may not have a tempBounds
    const oldBounds = this.tempBounds || {
      north: -1,
      south: -1,
      east: -1,
      west: -1
    };
    const newBounds = this.rectangle.getBounds().toJSON();
    if (Math.abs(newBounds.north - oldBounds.north) > this.sensitivity || Math.abs(newBounds.south - oldBounds.south) > this.sensitivity || Math.abs(newBounds.east - oldBounds.east) > this.sensitivity || Math.abs(newBounds.west - oldBounds.west) > this.sensitivity) {
      this.tempBounds = newBounds;
      this.$emit('bounds-changed', newBounds);
      // TODO: Remove in major release
      this.$emit('boundsChanged', newBounds); // eslint-disable-line
    }
  }

  mounted() {
    this.rectangle = new globalThis.google.maps.Rectangle({
      map: this.getMap(),
      ...this._options
    });
    this.rectangle.addListener('bounds_changed', () => this.changedBounds());
    this.rectangle.addListener('click', e => this.$emit('click', e));
    this.rectangle.addListener('dblclick', e => this.$emit('double-click', e));
    this.rectangle.addListener('drag', e => this.$emit('drag', e.latLng ? e.latLng.toJSON() : null));
    this.rectangle.addListener('dragend', e => this.$emit('drag-end', e.latLng ? e.latLng.toJSON() : null));
    this.rectangle.addListener('dragstart', e => this.$emit('drag-start', e.latLng ? e.latLng.toJSON() : null));
    this.rectangle.addListener('mouseover', e => this.$emit('mouseover', e));
    this.rectangle.addListener('rightclick', e => this.$emit('right-click', e));
    // TODO: Remove in major release
    this.rectangle.addListener('dblclick', e => this.$emit('doubleClick', e)); // eslint-disable-line
    this.rectangle.addListener('dragend', e => this.$emit('dragEnd', e.latLng ? e.latLng.toJSON() : null)); // eslint-disable-line
    this.rectangle.addListener('dragstart', e => this.$emit('dragStart', e.latLng ? e.latLng.toJSON() : null)); // eslint-disable-line
    this.rectangle.addListener('rightclick', e => this.$emit('rightClick', e)); // eslint-disable-line
  }

  beforeDestroy() {
    if (this.rectangle) this.rectangle.setMap(null);
  }
  render() {
    return null;
  }
}, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "getMap", [_dec], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "sensitivity", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "bounds", [_dec3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "clickable", [_dec4], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "draggable", [_dec5], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "editable", [_dec6], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "fillColor", [_dec7], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "fillOpacity", [_dec8], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "strokeColor", [_dec9], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, "strokeOpacity", [_dec10], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor11 = _applyDecoratedDescriptor(_class2.prototype, "strokePosition", [_dec11], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor12 = _applyDecoratedDescriptor(_class2.prototype, "strokeWeight", [_dec12], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor13 = _applyDecoratedDescriptor(_class2.prototype, "visible", [_dec13], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor14 = _applyDecoratedDescriptor(_class2.prototype, "zIndex", [_dec14], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _applyDecoratedDescriptor(_class2.prototype, "_optionsChanged", [_dec15], Object.getOwnPropertyDescriptor(_class2.prototype, "_optionsChanged"), _class2.prototype)), _class2)) || _class);// install function executed by Vue.use()
const install = function installX5Gmaps(Vue, options) {
  if (!options) throw new Error(`x5-gmaps :: (Google API) 'key' is required for plugin install.`);
  if (typeof options === 'string') init({
    key: options,
    libraries: []
  });else init(options);
  Vue.prototype.$GMaps = () => gmaps;
};var components=/*#__PURE__*/Object.freeze({__proto__:null,install:install,gmaps:gmaps,gmapsMap:__vue_component__$3,gmapsCircle:GmapsCircle,gmapsCluster:__vue_component__$1,gmapsData:GmapsData,gmapsDataGeoJson:GmapsDataGeoJson,gmapsHeatmap:GmapsHeatmap,gmapsInfoWindow:GmapsInfoWindow,gmapsMarker:GmapsMarker,gmapsPolygon:GmapsPolygon,gmapsPolyline:GmapsPolyline,gmapsPopup:__vue_component__,gmapsRectangle:GmapsRectangle,'default':install});// iife/cjs usage extends esm default export - so import it all

// Attach named exports directly to plugin. IIFE/CJS will
// only expose one global var, with component exports exposed as properties of
// that global var (eg. plugin.component)

Object.entries(components).forEach(_ref => {
  let [componentName, component] = _ref;
  if (componentName !== 'default') {
    const key = componentName;
    const val = component;
    install[key] = val;
  }
});module.exports=install;